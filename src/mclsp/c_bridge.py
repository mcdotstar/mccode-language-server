"""
Tier-1 C bridge: extract C regions from a McCode parse tree and stitch them
into a single virtual C document suitable for clangd.

The virtual document uses ``#line`` directives so that clangd reports
diagnostics at positions in the **original McCode file**, not in the virtual
document.  The LSP server exposes the virtual document via a custom request
so that VS Code (or any client) can open it as a ``mccode-c://`` URI and
delegate C language features to clangd.

Position map
------------
Each :class:`CRegion` records:

* ``mccode_line``  – 1-based line of the first *content* line in the McCode
  file (the line after ``%{``).
* ``virtual_line`` – 1-based line in the virtual C document where that same
  content appears (set by :meth:`VirtualCDocument._build`).

Given a McCode (line, col) inside a region the virtual position is::

    virtual_line  = region.virtual_line + (mccode_line - region.mccode_line)
    virtual_col   = col   # column is preserved; stubs may shift this slightly

The reverse mapping (virtual → McCode) is needed to translate clangd's
diagnostic / hover positions back to the editor.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from mclsp.document import ParsedDocument


# ---------------------------------------------------------------------------
# McCode runtime stub – shared across all virtual documents
# ---------------------------------------------------------------------------

# A minimal set of types, macros and extern declarations that cover the most
# commonly used McCode identifiers.  The goal is to let clangd resolve the
# most common names without flooding the user with "undefined identifier"
# errors on legitimate McCode boilerplate.
_MCSTAS_STUB = """\
/* McCode IDE stub – generated by mclsp (McStas flavour) */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#ifndef MCNUM
typedef double MCNUM;
#endif
#ifndef string
typedef char* string;
#endif
typedef long MCIDX;
typedef int   mcbool;

/* Particle runtime variables – available inside TRACE / INITIALIZE / etc. */
extern double x, y, z;
extern double vx, vy, vz;
extern double t, p;
extern double sx, sy, sz;
extern double mcgravitation, mcMagnet;
extern int    allow_backprop;
extern double _mctmp_a, _mctmp_b, _mctmp_c;

/* Particle state accessors (normally macros that deref _particle) */
#define SCATTERED  0
#define ABSORBED   0
#define RESTORE    0

/* Control-flow macros */
#define SCATTER    do { } while(0)
#define ABSORB     do { } while(0)
#define REMOVABLE  /**/
#define NOSPLIT    /**/

/* Utility macros */
#define SIG_MESSAGE(x)         do { } while(0)
#define STORE_NEUTRON(...)     do { } while(0)
#define RESTORE_NEUTRON(...)   do { } while(0)
#define ALLOW_BACKPROP         do { } while(0)
#define RAD2DEG  (180.0/M_PI)
#define DEG2RAD  (M_PI/180.0)
"""

_MCXTRACE_STUB = """\
/* McCode IDE stub – generated by mclsp (McXtrace flavour) */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#ifndef MCNUM
typedef double MCNUM;
#endif
#ifndef string
typedef char* string;
#endif
typedef long MCIDX;
typedef int   mcbool;

/* Particle runtime variables */
extern double x, y, z;
extern double kx, ky, kz;
extern double phi, t, p;
extern double Ex, Ey, Ez;
extern double _mctmp_a, _mctmp_b, _mctmp_c;

#define SCATTERED  0
#define ABSORBED   0
#define RESTORE    0

#define SCATTER    do { } while(0)
#define ABSORB     do { } while(0)
#define REMOVABLE  /**/
#define NOSPLIT    /**/

#define SIG_MESSAGE(x)       do { } while(0)
#define STORE_XRAY(...)      do { } while(0)
#define RESTORE_XRAY(...)    do { } while(0)
#define RAD2DEG  (180.0/M_PI)
#define DEG2RAD  (M_PI/180.0)
"""


# ---------------------------------------------------------------------------
# Data structures
# ---------------------------------------------------------------------------

@dataclass
class CRegion:
    """One ``%{ … %}`` block extracted from a McCode source file."""
    section: str         # 'global', 'share', 'declare', 'uservars',
                         # 'initialize', 'trace', 'save', 'finally', 'display'
    label: str           # Human-readable label (e.g. 'DECLARE', 'EXTEND MyComp')

    # Source positions in the McCode file (1-based lines, 0-based columns).
    # These point to the ``%{`` token itself.
    mccode_token_line: int
    mccode_token_col: int

    # First line of *content* (the line after ``%{``).  Used for #line.
    mccode_line: int      # 1-based

    # Raw C text between ``%{`` and ``%}`` (may start/end with newlines).
    content: str

    # Set by VirtualCDocument._build() once all regions are assembled.
    virtual_line: int = 0   # 1-based line in the virtual C document


@dataclass
class VirtualCDocument:
    """A stitched C document built from all C blocks in a McCode file."""
    source_uri: str                      # original McCode document URI
    source_filename: str                 # basename used in #line directives
    virtual_source: str                  # the complete virtual .c text
    regions: list[CRegion] = field(default_factory=list)

    def mccode_to_virtual(self, line: int, col: int) -> tuple[int, int] | None:
        """Map a McCode (line, col) to a virtual-C (line, col).

        Returns ``None`` if the position is not inside any C region.
        Line and column are both 1-based here for symmetry with LSP positions
        (callers convert from 0-based LSP positions before calling).
        """
        for reg in self.regions:
            content_lines = reg.content.splitlines()
            last_line = reg.mccode_line + max(len(content_lines) - 1, 0)
            if reg.mccode_line <= line <= last_line:
                offset = line - reg.mccode_line
                return reg.virtual_line + offset, col
        return None

    def virtual_to_mccode(self, vline: int, vcol: int) -> tuple[str, int, int] | None:
        """Map a virtual-C (vline, vcol) back to the McCode (uri, line, col).

        Returns ``(source_uri, line, col)`` or ``None``.
        """
        for reg in self.regions:
            content_lines = reg.content.splitlines()
            vlast = reg.virtual_line + max(len(content_lines) - 1, 0)
            if reg.virtual_line <= vline <= vlast:
                offset = vline - reg.virtual_line
                return self.source_uri, reg.mccode_line + offset, vcol
        return None

    def region_at_mccode(self, line: int, col: int) -> CRegion | None:
        """Return the CRegion that contains McCode position (line, col), or None."""
        for reg in self.regions:
            content_lines = reg.content.splitlines()
            last_line = reg.mccode_line + max(len(content_lines) - 1, 0)
            if reg.mccode_line <= line <= last_line:
                return reg
        return None


# ---------------------------------------------------------------------------
# Extraction helpers
# ---------------------------------------------------------------------------

def _token_to_region(token, section: str, label: str) -> CRegion:
    """Build a CRegion from an ANTLR4 UnparsedBlock *token*."""
    text = token.text          # full text: '%{...%}'
    content = text[2:-2]       # strip '%{' and '%}'
    # Determine the first content line (the line after '%{').
    token_line = token.line    # 1-based
    # Count leading newline(s) in content to find actual first content line.
    leading_newlines = len(content) - len(content.lstrip('\n'))
    mccode_line = token_line + 1 + (leading_newlines - 1 if leading_newlines else 0)
    if leading_newlines:
        content = content[leading_newlines:]   # strip leading blank lines
    return CRegion(
        section=section,
        label=label,
        mccode_token_line=token_line,
        mccode_token_col=token.column,
        mccode_line=mccode_line,
        content=content,
    )


def _multi_block_regions(multi_block_ctx, section: str, label: str) -> list[CRegion]:
    """Extract all unparsed_block tokens from a *multi_block* context."""
    if multi_block_ctx is None or multi_block_ctx.children is None:
        return []
    from antlr4 import TerminalNode
    regions = []
    for child in multi_block_ctx.children:
        if not isinstance(child, TerminalNode):
            # unparsed_block context
            tok = child.UnparsedBlock().symbol
            regions.append(_token_to_region(tok, section, label))
    return regions


def _extract_instr_regions(tree) -> list[CRegion]:
    """Walk an instrument parse tree and return all C regions in source order."""
    from antlr4 import TerminalNode
    regions: list[CRegion] = []
    instr = tree.instrument_definition()
    if instr is None:
        return regions

    # DECLARE
    if instr.declare() is not None:
        regions.extend(_multi_block_regions(instr.declare().multi_block(),
                                             'declare', 'DECLARE'))
    # USERVARS
    if instr.uservars() is not None:
        regions.extend(_multi_block_regions(instr.uservars().multi_block(),
                                             'uservars', 'USERVARS'))
    # INITIALIZE
    if instr.initialise() is not None:
        regions.extend(_multi_block_regions(instr.initialise().multi_block(),
                                             'initialize', 'INITIALIZE'))
    # TRACE section — EXTEND blocks on component instances
    trace = instr.instrument_trace()
    if trace is not None and trace.children is not None:
        for child in trace.children:
            if isinstance(child, TerminalNode):
                continue
            cname = type(child).__name__
            if cname == 'Component_instanceContext':
                inst_name = child.instance_name().getText() if child.instance_name() else '?'
                ext = child.extend() if hasattr(child, 'extend') else None
                if ext is not None and ext.unparsed_block() is not None:
                    tok = ext.unparsed_block().UnparsedBlock().symbol
                    regions.append(_token_to_region(tok, 'trace',
                                                    f'EXTEND {inst_name}'))
    # SAVE
    if instr.save() is not None:
        regions.extend(_multi_block_regions(instr.save().multi_block(),
                                             'save', 'SAVE'))
    # FINALLY
    if instr.finally_() is not None:
        regions.extend(_multi_block_regions(instr.finally_().multi_block(),
                                             'finally', 'FINALLY'))

    # Sort by source position so the position map is ordered.
    regions.sort(key=lambda r: r.mccode_token_line)
    return regions


def _extract_comp_regions(tree) -> list[CRegion]:
    """Walk a component parse tree and return all C regions in source order."""
    regions: list[CRegion] = []
    comp_def = tree.component_definition()
    if comp_def is None:
        return regions

    # Use the *New* variant if present (copy-defs have a different shape).
    ctx = comp_def

    def _try(getter, section, label):
        try:
            node = getter()
        except Exception:
            return
        if node is not None:
            regions.extend(_multi_block_regions(node.multi_block(), section, label))

    _try(lambda: ctx.share() if hasattr(ctx, 'share') else None, 'share', 'SHARE')
    _try(lambda: ctx.declare() if hasattr(ctx, 'declare') else None, 'declare', 'DECLARE')
    _try(lambda: ctx.uservars() if hasattr(ctx, 'uservars') else None, 'uservars', 'USERVARS')
    _try(lambda: ctx.initialise() if hasattr(ctx, 'initialise') else None, 'initialize', 'INITIALIZE')
    # component_trace
    if hasattr(ctx, 'component_trace') and ctx.component_trace() is not None:
        regions.extend(_multi_block_regions(ctx.component_trace().multi_block(),
                                             'trace', 'TRACE'))
    _try(lambda: ctx.save() if hasattr(ctx, 'save') else None, 'save', 'SAVE')
    _try(lambda: ctx.finally_() if hasattr(ctx, 'finally_') else None, 'finally', 'FINALLY')
    _try(lambda: ctx.display() if hasattr(ctx, 'display') else None, 'display', 'DISPLAY')

    regions.sort(key=lambda r: r.mccode_token_line)
    return regions


# ---------------------------------------------------------------------------
# Parameter extraction
# ---------------------------------------------------------------------------

def _instr_param_stubs(tree) -> list[str]:
    """Return C declarations for all DEFINE PARAMETERS of an instrument."""
    lines: list[str] = []
    instr = tree.instrument_definition()
    if instr is None or instr.instrument_parameters() is None:
        return lines
    for p in instr.instrument_parameters().instrument_parameter():
        name = p.Identifier().getText()
        cname = type(p).__name__
        if cname == 'InstrumentParameterIntegerContext':
            lines.append(f'int {name} = 0; /* DEFINE PARAMETER */')
        elif cname == 'InstrumentParameterStringContext':
            lines.append(f'char* {name} = NULL; /* DEFINE PARAMETER */')
        else:
            lines.append(f'double {name} = 0.0; /* DEFINE PARAMETER */')
    return lines


def _comp_param_stubs(tree) -> list[str]:
    """Return C declarations for all DEFINE/SETTING/OUTPUT PARAMETERS of a comp."""
    lines: list[str] = []
    comp_def = tree.component_definition()
    if comp_def is None:
        return lines

    ps = comp_def.component_parameter_set() if hasattr(comp_def, 'component_parameter_set') else None
    if ps is None:
        return lines

    def _add_params(getter, comment):
        try:
            node = getter()
        except Exception:
            return
        if node is None:
            return
        params_ctx = node.component_parameters() if hasattr(node, 'component_parameters') else None
        if params_ctx is None:
            return
        for p in (params_ctx.component_parameter() or []):
            name = p.Identifier().getText() if hasattr(p, 'Identifier') else '?'
            cname = type(p).__name__
            if 'Integer' in cname:
                lines.append(f'int {name} = 0; /* {comment} */')
            elif 'String' in cname:
                lines.append(f'char* {name} = NULL; /* {comment} */')
            else:
                lines.append(f'double {name} = 0.0; /* {comment} */')

    _add_params(lambda: ps.component_define_parameters() if hasattr(ps, 'component_define_parameters') else None,
                'DEFINE PARAMETER')
    _add_params(lambda: ps.component_set_parameters() if hasattr(ps, 'component_set_parameters') else None,
                'SETTING PARAMETER')
    _add_params(lambda: ps.component_out_parameters() if hasattr(ps, 'component_out_parameters') else None,
                'OUTPUT PARAMETER')
    return lines


# ---------------------------------------------------------------------------
# Virtual document builder
# ---------------------------------------------------------------------------

# Sections that contain function-body code (need to be wrapped in a function).
_BODY_SECTIONS = {'initialize', 'trace', 'save', 'finally', 'display'}
# Sections that live at file scope.
_FILE_SECTIONS = {'global', 'share', 'declare', 'uservars'}


def _build_virtual_source(regions: list[CRegion], param_stubs: list[str],
                           source_filename: str, flavor: str) -> str:
    """Assemble the virtual C document and fill in ``region.virtual_line``."""
    stub = _MCXTRACE_STUB if flavor == 'mcxtrace' else _MCSTAS_STUB
    lines: list[str] = []

    def ln(text: str = '') -> None:
        lines.append(text)

    # --- stub header ---
    for s in stub.splitlines():
        ln(s)

    # --- parameter declarations ---
    if param_stubs:
        ln()
        ln('/* ---- Parameters ---- */')
        for s in param_stubs:
            ln(s)

    # Track which body-section wrapper is currently open.
    current_wrapper: str | None = None
    wrapper_counter = 0

    def open_wrapper(label: str) -> None:
        nonlocal current_wrapper, wrapper_counter
        if current_wrapper is not None:
            close_wrapper()
        wrapper_counter += 1
        safe = label.replace(' ', '_').replace('-', '_')
        fn_name = f'__mclsp_{safe}_{wrapper_counter}'
        ln()
        ln(f'static void {fn_name}(void) {{')
        # re-declare params as locals so they resolve inside the function
        for s in param_stubs:
            ln(f'  {s}')
        current_wrapper = fn_name

    def close_wrapper() -> None:
        nonlocal current_wrapper
        if current_wrapper is not None:
            ln('}')
            current_wrapper = None

    for reg in regions:
        need_wrapper = reg.section in _BODY_SECTIONS

        if need_wrapper:
            open_wrapper(reg.label)
        else:
            close_wrapper()
            ln()
            ln(f'/* ---- {reg.label} ---- */')

        # Emit #line directive then content.
        ln(f'#line {reg.mccode_line} "{source_filename}"')
        reg.virtual_line = len(lines) + 1   # next line will be the content
        for content_line in reg.content.splitlines():
            ln(content_line)

    close_wrapper()
    ln()  # trailing newline

    return '\n'.join(lines) + '\n'


def build_virtual_c(doc: 'ParsedDocument', flavor: str = 'mcstas') -> VirtualCDocument | None:
    """Build a :class:`VirtualCDocument` from a parsed McCode document.

    Returns ``None`` if the document could not be parsed or has no C blocks.
    """
    if doc.tree is None:
        return None

    from pathlib import PurePosixPath
    filename = PurePosixPath(doc.uri).name

    if doc.suffix == '.instr':
        regions = _extract_instr_regions(doc.tree)
        param_stubs = _instr_param_stubs(doc.tree)
    elif doc.suffix == '.comp':
        regions = _extract_comp_regions(doc.tree)
        param_stubs = _comp_param_stubs(doc.tree)
    else:
        return None

    if not regions:
        return VirtualCDocument(
            source_uri=doc.uri,
            source_filename=filename,
            virtual_source='',
            regions=[],
        )

    virtual_source = _build_virtual_source(regions, param_stubs, filename, flavor)

    return VirtualCDocument(
        source_uri=doc.uri,
        source_filename=filename,
        virtual_source=virtual_source,
        regions=regions,
    )
